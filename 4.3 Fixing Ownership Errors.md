## Returning a Reference to the Stack
```rust
fn return_a_string() -> &String {
	let s = String::from("Hello world");
	&s
}
```

Fixes - extend the lifetime of the string:
Move ownership of the string out of the function
```rust
fn return_a_string() -> String {
	let s = String::from("Hello world");
	s
}
```

Return a string literal
```rust
fn return_a_string() -> &'static str { 
	"Hello world"
}
```

Defer borrow-checking to runtime by using garbage collection.
```rust
use std::rc::Rc;
fn return_a_string() -> Rc<String> {
	let s = Rc::new(String::from("Hello world"));
	Rc::clone(&s)
}
```

Have the caller provide a "slot" to put the string using a mutable reference:
```rust
fn return_a_string(output: &mut String) 
{ 
	output.replace_range(.., "Hello world"); 
}
```

## Not Enough Permission
`name` is an immutable reference.
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
	name.push(String::from("Esq."));
	let full = name.join("");
	full
}
```

Change the type of name from `&Vec<String>` to `&mut Vec<String>`. It's not idea since functions should not mutate their inputs if the caller would not expect it.
```rust
fn stringify_name_with_title(name: &mut Vec<String>) -> String {
    name.push(String::from("Esq."));
    let full = name.join(" ");
    full
}
```

Another option is to take ownership of the name, by changing `&Vec<String>` to `Vec<String>`. It's also not idea since it's very rare for Rust functions to take ownership of heap-owning data structure like `Vec` and `String`.
```rust
fn stringify_name_with_title(mut name: Vec<String>) -> String {
    name.push(String::from("Esq."));
    let full = name.join(" ");
    full
}
```

Clone the input `name`:
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    let mut name_clone = name.clone();
    name_clone.push(String::from("Esq."));
    let full = name_clone.join(" ");
    full
}```

The clone copies every string in the input. We can avoid unnecessary copies by adding the suffix later:
```rust
fn stringify_name_with_title(name: &Vec<String>) -> String {
    let mut full = name.join(" ");
    full.push_str(" Esq.");
    full
}```

## Aliasing and Mutating a Data Structure
```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest: &String = 
      dst.iter().max_by_key(|s| s.len()).unwrap();
    for s in src {
        if s.len() > largest.len() {
            dst.push(s.clone());
        }
    }
}
```

To fix this, the key insight is that we need to shorten the lifetime of `largest` to not overlap with `dst.push(..)`. One possible way is to clone `largest`.
```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest: String = dst.iter().max_by_key(|s| s.len()).unwrap().clone();
    for s in src {
        if s.len() > largest.len() {
            dst.push(s.clone());
        }
    }
}
```

Copy out the length of `largest`, since we don't actually need the contents of it.
```rust
fn add_big_strings(dst: &mut Vec<String>, src: &[String]) {
    let largest_len: usize = dst.iter().max_by_key(|s| s.len()).unwrap().len();
    for s in src {
        if s.len() > largest_len {
            dst.push(s.clone());
        }
    }
}
```

All share in common the key idea: shortening the lifetime of borrows on `dist` to not overlap with a mutation to it.

## Copying vs. Moving Out of a Collection
If a value does not own heap data, then it can be copied without a move.